{"remainingRequest":"C:\\Users\\luohoang\\Documents\\Project\\Th-lao-Fiber\\web\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\luohoang\\Documents\\Project\\Th-lao-Fiber\\web\\node_modules\\vue-excel-export\\VueComment.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Users\\luohoang\\Documents\\Project\\Th-lao-Fiber\\web\\node_modules\\vue-excel-export\\VueComment.vue","mtime":1608279312075},{"path":"C:\\Users\\luohoang\\Documents\\Project\\Th-lao-Fiber\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1608279293549},{"path":"C:\\Users\\luohoang\\Documents\\Project\\Th-lao-Fiber\\web\\node_modules\\babel-loader\\lib\\index.js","mtime":1608279291206},{"path":"C:\\Users\\luohoang\\Documents\\Project\\Th-lao-Fiber\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1608279293549},{"path":"C:\\Users\\luohoang\\Documents\\Project\\Th-lao-Fiber\\web\\node_modules\\vue-loader\\lib\\index.js","mtime":1608279312175}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBkb3dubG9hZCBmcm9tICJicm93c2VyLWRvd25sb2FkcyI7CgpleHBvcnQgZGVmYXVsdCB7CiAgICBuYW1lOiAnZXhwb3J0LWV4Y2VsJywKICAgIHByb3BzOiB7CiAgICAgICAgLy8gbWltZSB0eXBlIFt4bHMsIGNzdl0KICAgICAgICB0eXBlOiB7CiAgICAgICAgICAgIHR5cGU6IFN0cmluZywKICAgICAgICAgICAgZGVmYXVsdDogInhscyIKICAgICAgICB9LAogICAgICAgIC8vIEpzb24gdG8gZG93bmxvYWQKICAgICAgICBkYXRhOiB7CiAgICAgICAgICAgIHR5cGU6IEFycmF5LAogICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsCiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwKICAgICAgICB9LAogICAgICAgIC8vIGZpZWxkcyBpbnNpZGUgdGhlIEpzb24gT2JqZWN0IHRoYXQgeW91IHdhbnQgdG8gZXhwb3J0CiAgICAgICAgLy8gaWYgbm8gZ2l2ZW4sIGFsbCB0aGUgcHJvcGVydGllcyBpbiB0aGUgSnNvbiBhcmUgZXhwb3J0ZWQKICAgICAgICBmaWVsZHM6IHsKICAgICAgICAgICAgdHlwZTogT2JqZWN0LAogICAgICAgICAgICByZXF1aXJlZDogZmFsc2UKICAgICAgICB9LAogICAgICAgIC8vIHRoaXMgcHJvcCBpcyB1c2VkIHRvIGZpeCB0aGUgcHJvYmxlbSB3aXRoIG90aGVyIGNvbXBvbmVudHMgdGhhdCB1c2UgdGhlCiAgICAgICAgLy8gdmFyaWFibGUgZmllbGRzLCBsaWtlIHZlZS12YWxpZGF0ZS4gZXhwb3J0RmllbGRzIHdvcmtzIGV4YWN0bHkgbGlrZSBmaWVsZHMKICAgICAgICBleHBvcnRGaWVsZHM6IHsKICAgICAgICAgICAgdHlwZTogT2JqZWN0LAogICAgICAgICAgICByZXF1aXJlZDogZmFsc2UKICAgICAgICB9LAogICAgICAgIC8vIFVzZSBhcyBmYWxsYmFjayB3aGVuIHRoZSByb3cgaGFzIG5vIGZpZWxkIHZhbHVlcwogICAgICAgIGRlZmF1bHRWYWx1ZTogewogICAgICAgICAgICB0eXBlOiBTdHJpbmcsCiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSwKICAgICAgICAgICAgZGVmYXVsdDogIiIKICAgICAgICB9LAogICAgICAgIC8vIFRpdGxlKHMpIGZvciB0aGUgZGF0YSwgY291bGQgYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyAobXVsdGlwbGUgdGl0bGVzKQogICAgICAgIHRpdGxlOiB7CiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwKICAgICAgICB9LAogICAgICAgIC8vIEZvb3RlcihzKSBmb3IgdGhlIGRhdGEsIGNvdWxkIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgKG11bHRpcGxlIGZvb3RlcnMpCiAgICAgICAgZm9vdGVyOiB7CiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwKICAgICAgICB9LAogICAgICAgIC8vIGZpbGVuYW1lIHRvIGV4cG9ydAogICAgICAgIG5hbWU6IHsKICAgICAgICAgICAgdHlwZTogU3RyaW5nLAogICAgICAgICAgICBkZWZhdWx0OiAiZGF0YS54bHMiCiAgICAgICAgfSwKICAgICAgICBmZXRjaDogewogICAgICAgICAgICB0eXBlOiBGdW5jdGlvbiwKICAgICAgICB9LAogICAgICAgIG1ldGE6IHsKICAgICAgICAgICAgdHlwZTogQXJyYXksCiAgICAgICAgICAgIGRlZmF1bHQ6ICgpID0+IFtdCiAgICAgICAgfSwKICAgICAgICB3b3Jrc2hlZXQ6IHsKICAgICAgICAgICAgdHlwZTogU3RyaW5nLAogICAgICAgICAgICBkZWZhdWx0OiAiU2hlZXQxIgogICAgICAgIH0sCiAgICAgICAgLy9ldmVudCBiZWZvcmUgZ2VuZXJhdGUgd2FzIGNhbGxlZAogICAgICAgIGJlZm9yZUdlbmVyYXRlOiB7CiAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLAogICAgICAgIH0sCiAgICAgICAgLy9ldmVudCBiZWZvcmUgZG93bmxvYWQgcG9wcyB1cAogICAgICAgIGJlZm9yZUZpbmlzaDogewogICAgICAgICAgICB0eXBlOiBGdW5jdGlvbiwKICAgICAgICB9LAogICAgfSwKICAgIGNvbXB1dGVkOiB7CiAgICAgICAgLy8gdW5pcXVlIGlkZW50aWZpZXIKICAgICAgICBpZE5hbWUoKSB7CiAgICAgICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTsKICAgICAgICAgICAgcmV0dXJuICJleHBvcnRfIiArIG5vdzsKICAgICAgICB9LAoKICAgICAgICBkb3dubG9hZEZpZWxkcygpIHsKICAgICAgICAgICAgaWYgKHRoaXMuZmllbGRzICE9PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLmZpZWxkczsKCiAgICAgICAgICAgIGlmICh0aGlzLmV4cG9ydEZpZWxkcyAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5leHBvcnRGaWVsZHM7CiAgICAgICAgfQogICAgfSwKICAgIG1ldGhvZHM6IHsKICAgICAgICBhc3luYyBnZW5lcmF0ZSgpIHsKICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmJlZm9yZUdlbmVyYXRlID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJlZm9yZUdlbmVyYXRlKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5mZXRjaCA9PT0gJ2Z1bmN0aW9uJyB8fCAhZGF0YSkKICAgICAgICAgICAgICAgIGRhdGEgPSBhd2FpdCB0aGlzLmZldGNoKCk7CgogICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGxldCBqc29uID0gdGhpcy5nZXRQcm9jZXNzZWRKc29uKGRhdGEsIHRoaXMuZG93bmxvYWRGaWVsZHMpOwogICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAiaHRtbCIpIHsKICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbWFpbmx5IGZvciB0ZXN0aW5nCiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHBvcnQoCiAgICAgICAgICAgICAgICAgICAgdGhpcy5qc29uVG9YTFMoanNvbiksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lLnJlcGxhY2UoIi54bHMiLCAiLmh0bWwiKSwKICAgICAgICAgICAgICAgICAgICAidGV4dC9odG1sIgogICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICJjc3YiKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHBvcnQoCiAgICAgICAgICAgICAgICAgICAgdGhpcy5qc29uVG9DU1YoanNvbiksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lLnJlcGxhY2UoIi54bHMiLCAiLmNzdiIpLAogICAgICAgICAgICAgICAgICAgICJhcHBsaWNhdGlvbi9jc3YiCiAgICAgICAgICAgICAgICApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cG9ydCgKICAgICAgICAgICAgICAgIHRoaXMuanNvblRvWExTKGpzb24pLAogICAgICAgICAgICAgICAgdGhpcy5uYW1lLAogICAgICAgICAgICAgICAgImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCIKICAgICAgICAgICAgKTsKICAgICAgICB9LAogICAgICAgIC8qCiAgICAgICAgICAgIFVzZSBkb3dubG9hZGpzIHRvIGdlbmVyYXRlIHRoZSBkb3dubG9hZCBsaW5rCiAgICAgICAgICAgICovCiAgICAgICAgZXhwb3J0OiBhc3luYyBmdW5jdGlvbiAoZGF0YSwgZmlsZW5hbWUsIG1pbWUpIHsKICAgICAgICAgICAgbGV0IGJsb2IgPSB0aGlzLmJhc2U2NFRvQmxvYihkYXRhLCBtaW1lKTsKICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmJlZm9yZUZpbmlzaCA9PT0gJ2Z1bmN0aW9uJykKICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYmVmb3JlRmluaXNoKCk7CiAgICAgICAgICAgIGRvd25sb2FkKGJsb2IsIGZpbGVuYW1lLCBtaW1lKTsKICAgICAgICB9LAogICAgICAgIC8qCiAgICAgICAgICAgIGpzb25Ub1hMUwogICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgVHJhbnNmb3JtIGpzb24gZGF0YSBpbnRvIGFuIHhtbCBkb2N1bWVudCB3aXRoIE1TIEV4Y2VsIGZvcm1hdCwgc2FkbHkKICAgICAgICAgICAgaXQgc2hvd3MgYSBwcm9tcHQgd2hlbiBpdCBvcGVucywgdGhhdCBpcyBhIGRlZmF1bHQgYmVoYXZpb3IgZm9yCiAgICAgICAgICAgIE1pY3Jvc29mdCBvZmZpY2UgYW5kIGNhbm5vdCBiZSBhdm9pZGVkLiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSBDU1YgZm9ybWF0IGluc3RlYWQuCiAgICAgICAgICAgICovCiAgICAgICAganNvblRvWExTKGRhdGEpIHsKICAgICAgICAgICAgbGV0IHhsc1RlbXAgPQogICAgICAgICAgICAgICAgJzxodG1sIHhtbG5zOm89InVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206b2ZmaWNlOm9mZmljZSIgeG1sbnM6eD0idXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTpvZmZpY2U6ZXhjZWwiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMtaHRtbDQwIj48aGVhZD48bWV0YSBuYW1lPVByb2dJZCBjb250ZW50PUV4Y2VsLlNoZWV0PiA8bWV0YSBuYW1lPUdlbmVyYXRvciBjb250ZW50PSJNaWNyb3NvZnQgRXhjZWwgMTEiPjxtZXRhIGh0dHAtZXF1aXY9IkNvbnRlbnQtVHlwZSIgY29udGVudD0idGV4dC9odG1sOyBjaGFyc2V0PVVURi04Ij48IS0tW2lmIGd0ZSBtc28gOV0+PHhtbD48eDpFeGNlbFdvcmtib29rPjx4OkV4Y2VsV29ya3NoZWV0cz48eDpFeGNlbFdvcmtzaGVldD48eDpOYW1lPiR7d29ya3NoZWV0fTwveDpOYW1lPjx4OldvcmtzaGVldE9wdGlvbnM+PHg6RGlzcGxheUdyaWRsaW5lcy8+PC94OldvcmtzaGVldE9wdGlvbnM+PC94OkV4Y2VsV29ya3NoZWV0PjwveDpFeGNlbFdvcmtzaGVldHM+PC94OkV4Y2VsV29ya2Jvb2s+PC94bWw+PCFbZW5kaWZdLS0+PHN0eWxlPmJyIHttc28tZGF0YS1wbGFjZW1lbnQ6IHNhbWUtY2VsbDt9PC9zdHlsZT48L2hlYWQ+PGJvZHk+PHRhYmxlPiR7dGFibGV9PC90YWJsZT48L2JvZHk+PC9odG1sPic7CiAgICAgICAgICAgIGxldCB4bHNEYXRhID0gIjx0aGVhZD4iOwogICAgICAgICAgICBjb25zdCBjb2xzcGFuID0gT2JqZWN0LmtleXMoZGF0YVswXSkubGVuZ3RoOwogICAgICAgICAgICBsZXQgX3NlbGYgPSB0aGlzOwoKICAgICAgICAgICAgLy9IZWFkZXIKICAgICAgICAgICAgaWYgKHRoaXMudGl0bGUgIT0gbnVsbCkgewogICAgICAgICAgICAgICAgeGxzRGF0YSArPSB0aGlzLnBhcnNlRXh0cmFEYXRhKAogICAgICAgICAgICAgICAgICAgIHRoaXMudGl0bGUsCiAgICAgICAgICAgICAgICAgICAgJzx0cj48dGggY29sc3Bhbj0iJyArIGNvbHNwYW4gKyAnIj4ke2RhdGF9PC90aD48L3RyPicKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vRmllbGRzCiAgICAgICAgICAgIHhsc0RhdGEgKz0gIjx0cj4iOwogICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gZGF0YVswXSkgewogICAgICAgICAgICAgICAgeGxzRGF0YSArPSAiPHRoPiIgKyBrZXkgKyAiPC90aD4iOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHhsc0RhdGEgKz0gIjwvdHI+IjsKICAgICAgICAgICAgeGxzRGF0YSArPSAiPC90aGVhZD4iOwoKICAgICAgICAgICAgLy9EYXRhCiAgICAgICAgICAgIHhsc0RhdGEgKz0gIjx0Ym9keT4iOwogICAgICAgICAgICBkYXRhLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHsKICAgICAgICAgICAgICAgIHhsc0RhdGEgKz0gIjx0cj4iOwogICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGl0ZW0pIHsKICAgICAgICAgICAgICAgICAgICB4bHNEYXRhICs9ICI8dGQ+IiArIF9zZWxmLnZhbHVlUmVmb3JtYXR0ZWRGb3JNdWx0aWxpbmVzKGl0ZW1ba2V5XSkgKyAiPC90ZD4iOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgeGxzRGF0YSArPSAiPC90cj4iOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgeGxzRGF0YSArPSAiPC90Ym9keT4iOwoKICAgICAgICAgICAgLy9Gb290ZXIKICAgICAgICAgICAgaWYgKHRoaXMuZm9vdGVyICE9IG51bGwpIHsKICAgICAgICAgICAgICAgIHhsc0RhdGEgKz0gIjx0Zm9vdD4iOwogICAgICAgICAgICAgICAgeGxzRGF0YSArPSB0aGlzLnBhcnNlRXh0cmFEYXRhKAogICAgICAgICAgICAgICAgICAgIHRoaXMuZm9vdGVyLAogICAgICAgICAgICAgICAgICAgICc8dHI+PHRkIGNvbHNwYW49IicgKyBjb2xzcGFuICsgJyI+JHtkYXRhfTwvdGQ+PC90cj4nCiAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgeGxzRGF0YSArPSAiPC90Zm9vdD4iOwogICAgICAgICAgICB9CgogICAgICAgICAgICByZXR1cm4geGxzVGVtcC5yZXBsYWNlKCIke3RhYmxlfSIsIHhsc0RhdGEpLnJlcGxhY2UoIiR7d29ya3NoZWV0fSIsIHRoaXMud29ya3NoZWV0KTsKICAgICAgICB9LAogICAgICAgIC8qCiAgICAgICAgICAgIGpzb25Ub0NTVgogICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgVHJhbnNmb3JtIGpzb24gZGF0YSBpbnRvIGFuIENTViBmaWxlLgogICAgICAgICAgICAqLwogICAgICAgIGpzb25Ub0NTVihkYXRhKSB7CiAgICAgICAgICAgIHZhciBjc3ZEYXRhID0gW107CiAgICAgICAgICAgIC8vSGVhZGVyCiAgICAgICAgICAgIGlmICh0aGlzLnRpdGxlICE9IG51bGwpIHsKICAgICAgICAgICAgICAgIGNzdkRhdGEucHVzaCh0aGlzLnBhcnNlRXh0cmFEYXRhKHRoaXMudGl0bGUsICIke2RhdGF9XHJcbiIpKTsKICAgICAgICAgICAgfQogICAgICAgICAgICAvL0ZpZWxkcwogICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gZGF0YVswXSkgewogICAgICAgICAgICAgICAgY3N2RGF0YS5wdXNoKGtleSk7CiAgICAgICAgICAgICAgICBjc3ZEYXRhLnB1c2goIiwiKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjc3ZEYXRhLnBvcCgpOwogICAgICAgICAgICBjc3ZEYXRhLnB1c2goIlxyXG4iKTsKICAgICAgICAgICAgLy9EYXRhCiAgICAgICAgICAgIGRhdGEubWFwKGZ1bmN0aW9uIChpdGVtKSB7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gaXRlbSkgewogICAgICAgICAgICAgICAgICAgIGxldCBlc2NhcGVkQ1NWID0gJz1cIicgKyBpdGVtW2tleV0gKyAnXCInOyAvLyBjYXN0IE51bWJlcnMgdG8gc3RyaW5nCiAgICAgICAgICAgICAgICAgICAgaWYgKGVzY2FwZWRDU1YubWF0Y2goL1ssIlxuXS8pKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRDU1YgPSAnIicgKyBlc2NhcGVkQ1NWLnJlcGxhY2UoL1wiL2csICciIicpICsgJyInOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBjc3ZEYXRhLnB1c2goZXNjYXBlZENTVik7CiAgICAgICAgICAgICAgICAgICAgY3N2RGF0YS5wdXNoKCIsIik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjc3ZEYXRhLnBvcCgpOwogICAgICAgICAgICAgICAgY3N2RGF0YS5wdXNoKCJcclxuIik7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICAvL0Zvb3RlcgogICAgICAgICAgICBpZiAodGhpcy5mb290ZXIgIT0gbnVsbCkgewogICAgICAgICAgICAgICAgY3N2RGF0YS5wdXNoKHRoaXMucGFyc2VFeHRyYURhdGEodGhpcy5mb290ZXIsICIke2RhdGF9XHJcbiIpKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gY3N2RGF0YS5qb2luKCIiKTsKICAgICAgICB9LAogICAgICAgIC8qCiAgICAgICAgICAgIGdldFByb2Nlc3NlZEpzb24KICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tCiAgICAgICAgICAgIEdldCBvbmx5IHRoZSBkYXRhIHRvIGV4cG9ydCwgaWYgbm8gZmllbGRzIGFyZSBzZXQgcmV0dXJuIGFsbCB0aGUgZGF0YQogICAgICAgICAgICAqLwogICAgICAgIGdldFByb2Nlc3NlZEpzb24oZGF0YSwgaGVhZGVyKSB7CiAgICAgICAgICAgIGxldCBrZXlzID0gdGhpcy5nZXRLZXlzKGRhdGEsIGhlYWRlcik7CiAgICAgICAgICAgIGxldCBuZXdEYXRhID0gW107CiAgICAgICAgICAgIGxldCBfc2VsZiA9IHRoaXM7CiAgICAgICAgICAgIGRhdGEubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkgewogICAgICAgICAgICAgICAgbGV0IG5ld0l0ZW0gPSB7fTsKICAgICAgICAgICAgICAgIGZvciAobGV0IGxhYmVsIGluIGtleXMpIHsKICAgICAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBrZXlzW2xhYmVsXTsKICAgICAgICAgICAgICAgICAgICBuZXdJdGVtW2xhYmVsXSA9IF9zZWxmLmdldFZhbHVlKHByb3BlcnR5LCBpdGVtKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIG5ld0RhdGEucHVzaChuZXdJdGVtKTsKICAgICAgICAgICAgfSk7CgogICAgICAgICAgICByZXR1cm4gbmV3RGF0YTsKICAgICAgICB9LAogICAgICAgIGdldEtleXMoZGF0YSwgaGVhZGVyKSB7CiAgICAgICAgICAgIGlmIChoZWFkZXIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXI7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGxldCBrZXlzID0ge307CiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBkYXRhWzBdKSB7CiAgICAgICAgICAgICAgICBrZXlzW2tleV0gPSBrZXk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGtleXM7CiAgICAgICAgfSwKICAgICAgICAvKgogICAgICAgICAgICBwYXJzZUV4dHJhRGF0YQogICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgUGFyc2UgdGl0bGUgYW5kIGZvb3RlciBhdHRyaWJ1dGUgdG8gdGhlIGNzdiBmb3JtYXQKICAgICAgICAgICAgKi8KICAgICAgICBwYXJzZUV4dHJhRGF0YShleHRyYURhdGEsIGZvcm1hdCkgewogICAgICAgICAgICBsZXQgcGFyc2VEYXRhID0gIiI7CiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4dHJhRGF0YSkpIHsKICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXh0cmFEYXRhLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhICs9IGZvcm1hdC5yZXBsYWNlKCIke2RhdGF9IiwgZXh0cmFEYXRhW2ldKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHBhcnNlRGF0YSArPSBmb3JtYXQucmVwbGFjZSgiJHtkYXRhfSIsIGV4dHJhRGF0YSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHBhcnNlRGF0YTsKICAgICAgICB9LAoKICAgICAgICBnZXRWYWx1ZShrZXksIGl0ZW0pIHsKICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0eXBlb2Yga2V5ICE9PSAib2JqZWN0IiA/IGtleSA6IGtleS5maWVsZDsKICAgICAgICAgICAgbGV0IGluZGV4ZXMgPSB0eXBlb2YgZmllbGQgIT09ICJzdHJpbmciID8gW10gOiBmaWVsZC5zcGxpdCgiLiIpOwogICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmRlZmF1bHRWYWx1ZTsKCiAgICAgICAgICAgIGlmICghZmllbGQpCiAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0ZW07CiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ZXMubGVuZ3RoID4gMSkKICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRWYWx1ZUZyb21OZXN0ZWRJdGVtKGl0ZW0sIGluZGV4ZXMpOwogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VWYWx1ZShpdGVtW2ZpZWxkXSk7CgogICAgICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KCdjYWxsYmFjaycpKQogICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldFZhbHVlRnJvbUNhbGxiYWNrKHZhbHVlLCBrZXkuY2FsbGJhY2spOwoKICAgICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgIH0sCgogICAgICAgIC8qCiAgICAgICAgY29udmVydCB2YWx1ZXMgd2l0aCBuZXdsaW5lIFxuIGNoYXJhY3RlcnMgaW50byA8YnIvPgogICAgICAgICovCiAgICAgICAgdmFsdWVSZWZvcm1hdHRlZEZvck11bHRpbGluZXModmFsdWUpIHsKICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09ICJzdHJpbmciKSByZXR1cm4gKHZhbHVlLnJlcGxhY2UoL1xuL2lnLCAiPGJyLz4iKSk7CiAgICAgICAgICAgIGVsc2UgcmV0dXJuICh2YWx1ZSk7CiAgICAgICAgfSwKCiAgICAgICAgZ2V0VmFsdWVGcm9tTmVzdGVkSXRlbShpdGVtLCBpbmRleGVzKSB7CiAgICAgICAgICAgIGxldCBuZXN0ZWRJdGVtID0gaXRlbTsKICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggb2YgaW5kZXhlcykgewogICAgICAgICAgICAgICAgaWYgKG5lc3RlZEl0ZW0pCiAgICAgICAgICAgICAgICAgICAgbmVzdGVkSXRlbSA9IG5lc3RlZEl0ZW1baW5kZXhdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFsdWUobmVzdGVkSXRlbSk7CiAgICAgICAgfSwKCiAgICAgICAgZ2V0VmFsdWVGcm9tQ2FsbGJhY2soaXRlbSwgY2FsbGJhY2spIHsKICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gImZ1bmN0aW9uIikKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRWYWx1ZQogICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNhbGxiYWNrKGl0ZW0pOwogICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhbHVlKHZhbHVlKTsKICAgICAgICB9LAogICAgICAgIHBhcnNlVmFsdWUodmFsdWUpIHsKICAgICAgICAgICAgcmV0dXJuIHZhbHVlIHx8IHZhbHVlID09PSAwIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nCiAgICAgICAgICAgICAgICA/IHZhbHVlCiAgICAgICAgICAgICAgICA6IHRoaXMuZGVmYXVsdFZhbHVlOwogICAgICAgIH0sCiAgICAgICAgYmFzZTY0VG9CbG9iKGRhdGEsIG1pbWUpIHsKICAgICAgICAgICAgbGV0IGJhc2U2NCA9IHdpbmRvdy5idG9hKHdpbmRvdy51bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpKTsKICAgICAgICAgICAgbGV0IGJzdHIgPSBhdG9iKGJhc2U2NCk7CiAgICAgICAgICAgIGxldCBuID0gYnN0ci5sZW5ndGg7CiAgICAgICAgICAgIGxldCB1OGFyciA9IG5ldyBVaW50OENsYW1wZWRBcnJheShuKTsKICAgICAgICAgICAgd2hpbGUgKG4tLSkgewogICAgICAgICAgICAgICAgdThhcnJbbl0gPSBic3RyLmNoYXJDb2RlQXQobik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFt1OGFycl0sIHt0eXBlOiBtaW1lfSk7CiAgICAgICAgfQogICAgfSAvLyBlbmQgbWV0aG9kcwp9Owo="},{"version":3,"sources":["VueComment.vue"],"names":[],"mappings":";;;;;;;;;;;AAWA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"VueComment.vue","sourceRoot":"node_modules/vue-excel-export","sourcesContent":["<template>\r\n    <div\r\n            :id=\"idName\"\r\n            @click=\"generate\">\r\n        <slot>\r\n            Download {{name}}\r\n        </slot>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    import download from \"browser-downloads\";\r\n\r\n    export default {\r\n        name: 'export-excel',\r\n        props: {\r\n            // mime type [xls, csv]\r\n            type: {\r\n                type: String,\r\n                default: \"xls\"\r\n            },\r\n            // Json to download\r\n            data: {\r\n                type: Array,\r\n                required: false,\r\n                default: null\r\n            },\r\n            // fields inside the Json Object that you want to export\r\n            // if no given, all the properties in the Json are exported\r\n            fields: {\r\n                type: Object,\r\n                required: false\r\n            },\r\n            // this prop is used to fix the problem with other components that use the\r\n            // variable fields, like vee-validate. exportFields works exactly like fields\r\n            exportFields: {\r\n                type: Object,\r\n                required: false\r\n            },\r\n            // Use as fallback when the row has no field values\r\n            defaultValue: {\r\n                type: String,\r\n                required: false,\r\n                default: \"\"\r\n            },\r\n            // Title(s) for the data, could be a string or an array of strings (multiple titles)\r\n            title: {\r\n                default: null\r\n            },\r\n            // Footer(s) for the data, could be a string or an array of strings (multiple footers)\r\n            footer: {\r\n                default: null\r\n            },\r\n            // filename to export\r\n            name: {\r\n                type: String,\r\n                default: \"data.xls\"\r\n            },\r\n            fetch: {\r\n                type: Function,\r\n            },\r\n            meta: {\r\n                type: Array,\r\n                default: () => []\r\n            },\r\n            worksheet: {\r\n                type: String,\r\n                default: \"Sheet1\"\r\n            },\r\n            //event before generate was called\r\n            beforeGenerate: {\r\n                type: Function,\r\n            },\r\n            //event before download pops up\r\n            beforeFinish: {\r\n                type: Function,\r\n            },\r\n        },\r\n        computed: {\r\n            // unique identifier\r\n            idName() {\r\n                var now = new Date().getTime();\r\n                return \"export_\" + now;\r\n            },\r\n\r\n            downloadFields() {\r\n                if (this.fields !== undefined) return this.fields;\r\n\r\n                if (this.exportFields !== undefined) return this.exportFields;\r\n            }\r\n        },\r\n        methods: {\r\n            async generate() {\r\n                if (typeof this.beforeGenerate === 'function') {\r\n                    await this.beforeGenerate();\r\n                }\r\n                let data = this.data;\r\n                if (typeof this.fetch === 'function' || !data)\r\n                    data = await this.fetch();\r\n\r\n                if (!data || !data.length) {\r\n                    return;\r\n                }\r\n\r\n                let json = this.getProcessedJson(data, this.downloadFields);\r\n                if (this.type === \"html\") {\r\n                    // this is mainly for testing\r\n                    return this.export(\r\n                        this.jsonToXLS(json),\r\n                        this.name.replace(\".xls\", \".html\"),\r\n                        \"text/html\"\r\n                    );\r\n                } else if (this.type === \"csv\") {\r\n                    return this.export(\r\n                        this.jsonToCSV(json),\r\n                        this.name.replace(\".xls\", \".csv\"),\r\n                        \"application/csv\"\r\n                    );\r\n                }\r\n                return this.export(\r\n                    this.jsonToXLS(json),\r\n                    this.name,\r\n                    \"application/vnd.ms-excel\"\r\n                );\r\n            },\r\n            /*\r\n                Use downloadjs to generate the download link\r\n                */\r\n            export: async function (data, filename, mime) {\r\n                let blob = this.base64ToBlob(data, mime);\r\n                if (typeof this.beforeFinish === 'function')\r\n                    await this.beforeFinish();\r\n                download(blob, filename, mime);\r\n            },\r\n            /*\r\n                jsonToXLS\r\n                ---------------\r\n                Transform json data into an xml document with MS Excel format, sadly\r\n                it shows a prompt when it opens, that is a default behavior for\r\n                Microsoft office and cannot be avoided. It's recommended to use CSV format instead.\r\n                */\r\n            jsonToXLS(data) {\r\n                let xlsTemp =\r\n                    '<html xmlns:o=\"urn:schemas-microsoft-com:office:office\" xmlns:x=\"urn:schemas-microsoft-com:office:excel\" xmlns=\"http://www.w3.org/TR/REC-html40\"><head><meta name=ProgId content=Excel.Sheet> <meta name=Generator content=\"Microsoft Excel 11\"><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet><x:Name>${worksheet}</x:Name><x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions></x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]--><style>br {mso-data-placement: same-cell;}</style></head><body><table>${table}</table></body></html>';\r\n                let xlsData = \"<thead>\";\r\n                const colspan = Object.keys(data[0]).length;\r\n                let _self = this;\r\n\r\n                //Header\r\n                if (this.title != null) {\r\n                    xlsData += this.parseExtraData(\r\n                        this.title,\r\n                        '<tr><th colspan=\"' + colspan + '\">${data}</th></tr>'\r\n                    );\r\n                }\r\n\r\n                //Fields\r\n                xlsData += \"<tr>\";\r\n                for (let key in data[0]) {\r\n                    xlsData += \"<th>\" + key + \"</th>\";\r\n                }\r\n                xlsData += \"</tr>\";\r\n                xlsData += \"</thead>\";\r\n\r\n                //Data\r\n                xlsData += \"<tbody>\";\r\n                data.map(function (item, index) {\r\n                    xlsData += \"<tr>\";\r\n                    for (let key in item) {\r\n                        xlsData += \"<td>\" + _self.valueReformattedForMultilines(item[key]) + \"</td>\";\r\n                    }\r\n                    xlsData += \"</tr>\";\r\n                });\r\n                xlsData += \"</tbody>\";\r\n\r\n                //Footer\r\n                if (this.footer != null) {\r\n                    xlsData += \"<tfoot>\";\r\n                    xlsData += this.parseExtraData(\r\n                        this.footer,\r\n                        '<tr><td colspan=\"' + colspan + '\">${data}</td></tr>'\r\n                    );\r\n                    xlsData += \"</tfoot>\";\r\n                }\r\n\r\n                return xlsTemp.replace(\"${table}\", xlsData).replace(\"${worksheet}\", this.worksheet);\r\n            },\r\n            /*\r\n                jsonToCSV\r\n                ---------------\r\n                Transform json data into an CSV file.\r\n                */\r\n            jsonToCSV(data) {\r\n                var csvData = [];\r\n                //Header\r\n                if (this.title != null) {\r\n                    csvData.push(this.parseExtraData(this.title, \"${data}\\r\\n\"));\r\n                }\r\n                //Fields\r\n                for (let key in data[0]) {\r\n                    csvData.push(key);\r\n                    csvData.push(\",\");\r\n                }\r\n                csvData.pop();\r\n                csvData.push(\"\\r\\n\");\r\n                //Data\r\n                data.map(function (item) {\r\n                    for (let key in item) {\r\n                        let escapedCSV = '=\\\"' + item[key] + '\\\"'; // cast Numbers to string\r\n                        if (escapedCSV.match(/[,\"\\n]/)) {\r\n                            escapedCSV = '\"' + escapedCSV.replace(/\\\"/g, '\"\"') + '\"';\r\n                        }\r\n                        csvData.push(escapedCSV);\r\n                        csvData.push(\",\");\r\n                    }\r\n                    csvData.pop();\r\n                    csvData.push(\"\\r\\n\");\r\n                });\r\n                //Footer\r\n                if (this.footer != null) {\r\n                    csvData.push(this.parseExtraData(this.footer, \"${data}\\r\\n\"));\r\n                }\r\n                return csvData.join(\"\");\r\n            },\r\n            /*\r\n                getProcessedJson\r\n                ---------------\r\n                Get only the data to export, if no fields are set return all the data\r\n                */\r\n            getProcessedJson(data, header) {\r\n                let keys = this.getKeys(data, header);\r\n                let newData = [];\r\n                let _self = this;\r\n                data.map(function (item, index) {\r\n                    let newItem = {};\r\n                    for (let label in keys) {\r\n                        let property = keys[label];\r\n                        newItem[label] = _self.getValue(property, item);\r\n                    }\r\n                    newData.push(newItem);\r\n                });\r\n\r\n                return newData;\r\n            },\r\n            getKeys(data, header) {\r\n                if (header) {\r\n                    return header;\r\n                }\r\n\r\n                let keys = {};\r\n                for (let key in data[0]) {\r\n                    keys[key] = key;\r\n                }\r\n                return keys;\r\n            },\r\n            /*\r\n                parseExtraData\r\n                ---------------\r\n                Parse title and footer attribute to the csv format\r\n                */\r\n            parseExtraData(extraData, format) {\r\n                let parseData = \"\";\r\n                if (Array.isArray(extraData)) {\r\n                    for (var i = 0; i < extraData.length; i++) {\r\n                        parseData += format.replace(\"${data}\", extraData[i]);\r\n                    }\r\n                } else {\r\n                    parseData += format.replace(\"${data}\", extraData);\r\n                }\r\n                return parseData;\r\n            },\r\n\r\n            getValue(key, item) {\r\n                const field = typeof key !== \"object\" ? key : key.field;\r\n                let indexes = typeof field !== \"string\" ? [] : field.split(\".\");\r\n                let value = this.defaultValue;\r\n\r\n                if (!field)\r\n                    value = item;\r\n                else if (indexes.length > 1)\r\n                    value = this.getValueFromNestedItem(item, indexes);\r\n                else\r\n                    value = this.parseValue(item[field]);\r\n\r\n                if (key.hasOwnProperty('callback'))\r\n                    value = this.getValueFromCallback(value, key.callback);\r\n\r\n                return value;\r\n            },\r\n\r\n            /*\r\n            convert values with newline \\n characters into <br/>\r\n            */\r\n            valueReformattedForMultilines(value) {\r\n                if (typeof (value) == \"string\") return (value.replace(/\\n/ig, \"<br/>\"));\r\n                else return (value);\r\n            },\r\n\r\n            getValueFromNestedItem(item, indexes) {\r\n                let nestedItem = item;\r\n                for (let index of indexes) {\r\n                    if (nestedItem)\r\n                        nestedItem = nestedItem[index];\r\n                }\r\n                return this.parseValue(nestedItem);\r\n            },\r\n\r\n            getValueFromCallback(item, callback) {\r\n                if (typeof callback !== \"function\")\r\n                    return this.defaultValue\r\n                const value = callback(item);\r\n                return this.parseValue(value);\r\n            },\r\n            parseValue(value) {\r\n                return value || value === 0 || typeof value === 'boolean'\r\n                    ? value\r\n                    : this.defaultValue;\r\n            },\r\n            base64ToBlob(data, mime) {\r\n                let base64 = window.btoa(window.unescape(encodeURIComponent(data)));\r\n                let bstr = atob(base64);\r\n                let n = bstr.length;\r\n                let u8arr = new Uint8ClampedArray(n);\r\n                while (n--) {\r\n                    u8arr[n] = bstr.charCodeAt(n);\r\n                }\r\n                return new Blob([u8arr], {type: mime});\r\n            }\r\n        } // end methods\r\n    };\r\n</script>\r\n"]}]}